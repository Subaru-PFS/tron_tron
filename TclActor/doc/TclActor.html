<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
	<title>TclActor</title>
</head>
<body>
<h1>TclActor</h1>

<p>TclActor is a set of classes that allow one to write an actor for the 3.5m control system. An actor can be a script running in the hub (aka "tron") or an Instrument Control Computer (ICC) running elsewhere.

<p>TclActor is written in Python and uses the tcl event loop (via Tkinter) for cooperative multitasking. This is as opposed to Actor, the original hub actor that used multithreading. Cooperative multitasking generally results in simpler code than multithreaded code. However, one must be careful not to take too long while executing a particular event.

<p>TclActor is intrinsically asynchronous. Thus, to the extent that the underlying hardware controllers support it, the Tcl Actor can execute multiple commands at the same time. If a new command is received while an old command is executing then the new command will either be accepted (if compatible) or rejected (if not). Note that it will *not* be queued up; this simplifies programming and removes the need for commands to report and clear the queue.

<p>Commands must be in the following format:
  [cmdId [msgId]] [verb [arguments]]
where:
<ul>
<li> cmdId: command ID assigned by the user (typically the hub); it is used to tag replies generated by the command. If omitted then 0 is used. A command ID of 0 is also used for unsolicited replies so please never use cmdId = 0 if you want to track replies to a command.
<li> msgId: ignored.
<li> verb: a word containing only letters, numbers and/or _ (underscore)
<li> arguments: an arbitrary string whose format depends upon the verb
</ul>

<p>Replies are prefixed with the cmdId of the triggering command (or 0 if the reply is unsolicited) and the user ID (always 0 for a single-user actor).

<h2><a name="WritingAnActor"></a>Writing an Actor or ICC</h2>

<h3>Write code for devices</h3>

<p>An actor typically controls one or more devices. For example an Instrument Control Computer (ICC) controls an imager and often a filterwheel or slit turret. A hub actor typically controls an ICC or other hardware controller. 

<p>For each device controlled by your actor: write a software representation of this device as a sublcass of TclActor.Device or TclActor.TCPDevice. This is a very important part of the actor; expect to spend at least half your time on this task.

<h3>Write code for the actor</h3>

<p>Write one actor as a sublcass of TclActor.Actor. This contains the list of devices your actor controls and code to execute various commands. These commands fall into several categories:
<ul>
    <li>Local commands: these are commands implemented as methods of your actor class. Each such method must be named cmd_<i>verb</i> where <i>verb</i> is the command verb. The first line of the doc string for that method is the help for that command (as printed by the command "help"). Note that TclActor.Actor implements several local commands; do not override these unless you are sure you know what you are doing. These include:
    <ul>
        <li>help
        <li>connDev/disconnDev: connect or disconnect a device (all devices by default)
        <li><i>dev</i>: send text directly to a device
    </ul>
    <li>Device commands: these are commands that are forwarded to a device. In other words if command "foo" is handled by device "barDev" then command "foo foo-args" will have the same effect as "barDev foo foo-args". The list of such commands for each device is part of that device.
</ul>

<h3>Command Objects</h3>

<p>As each command string is received by the actor it is parsed and turned into a UserCmd object. This object contains:
<ul>
<li> user ID
<li> command ID
<li> command verb
<li> command arguments (unparsed)
<li> command state (e.g. running, done or failed)
</ul>

<p>The actor then executes the UserCmd object as follows:

<ul>
    <li>Check the command by calling checkLocalCmd

    <p>This verifies that the new command is compatible with whatever else is going on at the time. If there are conditions that prevent a command from executing then you should override checkLocalCmd and add code to detect this (though you may put such code into the code for the command itself if you prefer).

    <p>You may also put code in checkLocalCmd to supersede other commands. But that is more likely to be done in the code that executes a particular command.

    <li>Execute the command

    <p>For a local command this is in a method called cmd_<i>verb</i> where <i>verb</i> is the command verb. This code should:
    <ul>
        <li>parse the arguments (if any)
        <li>check for conditions that would prevent it from being executed (though this is usually done in checkLocalCmd)
        <li>check for commands that must be superseded; if any are found then it should start this process and queue the command to be run once the superseding is done.
        <li>if the command is quick:
        <ul>
            <li>execute the command
            <li>set final status of command to "done" or "failed" as appropriate
        </ul>
        <li>if the command is slow:
        <ul>
            <li>start executing the command
            <li>use code placed elsewhere (often in a state callback for a device) to check the status of the command
        </ul>
        <li>when the command is done then some code somewhere must set final status of command to "done" or "failed"
    </ul>
</ul>

<p>In addition whenever you send a command to a device you create a DevCmd object which is very similar to a UserCmd has slightly different information. It is possible to tie a UserCmd to a DevCmd such that the state of the former tracks the state of the latter. This is especially useful when a user command can be directly handled by a device (perhaps after some initial massaging).

</body>
</html>